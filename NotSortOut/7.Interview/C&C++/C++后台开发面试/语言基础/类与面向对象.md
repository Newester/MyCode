# **面向对象基本特性：抽象、封装、继承、多态**

---

### **抽象 = 数据抽象 + 行为抽象**

---

### **封装**

    将抽象的数据和行为相结合，形成一个有机的整体（类），提供外部使用的接口， 隐藏内部的实现。
 
**访问权限** : public protected private

    public: 类的外部可以访问

    protected: 类和类的子类可以访问

    private: 仅在本类中可以访问

### **继承**

    使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

**继承权限** : public protected private

    public: 基类的public成员是派生类的public成员，基类的protected成员是派生类的protected的成员，基类的private成员不可见，仅能通过基类接口访问

    protected: 基类的public成员和protected成员是派生类的protected成员，基类的private成员不可见，仅能通过基类接口访问

    private: 基类的public成员和protected成员是派生类的private成员，基类的private成员不可见，仅能通过基类接口访问

**隐藏**

    派生类会隐藏基类中同名的数据成员与函数成员（不需要相同的形参列表，如果相同，当基类带有virtual属性才会隐藏） ，要使用基类的作用域符才能使用基类的同名成员

**虚继承**

    指定virtual关键字的继承，通常用来解决钻石继承中的二义性问题，被虚继承的类在派生类中只有一份拷贝。
    MSVC下虚继承通常通过虚基类指针和虚基类表来实现，虚基类表不占用类对象的存储空间，别的编译器一般是虚表的偏移量

**多继承**

    C++支持多继承，内存分布顺序越靠近派生类的越靠前

**构造与析构**

    构造函数的执行顺序为：基类构造函数 --> 类成员构造函数 --> 派生类构造函数
    多继承构造函数的执行顺序按照声明的顺序执行
    析构函数的执行顺序与构造函数的相反

**接口继承与实现继承**

    接口继承：派生类只继承基类的函数声明，自己实现（不同的版本）
    实现继承：派生类继承了基类的函数定义

## **多态**

    多态：同样的消息被不同类型的对象接收时导致不同的行为
    静态多态性：编译期根据函数实参的类型推断要调用的函数，静态多态性通过函数重载来实现
    动态多态性：在程序执行期间判断对象的类型调用相对应的方法，动态多态性通过派生类重写基类的虚函数，以及基类指针或引用指向派生类对象来实现

**函数重载**

    同一作用域内的几个函数名字相同但形参列表不同

**运算符重载**

    相当于函数名为“operator+重载运算符”的函数重载，有相应的形参列表和返回类型
    重载运算符不能改变运算符的语法结构、操作数个数、优先级、结合性

**虚函数**

    被virtual 关键字修饰的成员函数，允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数

**虚表和虚表指针**

    每个包含了虚函数的类都包含了一个虚表；其每个实列对象都有一个虚表指针指向该虚表
    虚表中包含了虚函数的指针



