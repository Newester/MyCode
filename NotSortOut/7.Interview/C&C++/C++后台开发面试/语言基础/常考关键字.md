### const
**const 变量**

    const int a;

    不能修改值，必须初始化

**const 类对象**

    const MyClass a;

    不能修改成员变量的值，不能调用非 const 函数

**指向 const 变量的指针**

    const int * a;

    指向内容不可变，指向可变

**const 指针**

    int * const a;

    指向内容可变，指向不可变

**指向 const 变量的 const 指针**

    const int * const a;

    指向内容不可变，指向也不可变

**const 引用**

**const 变量作为函数参数**

    void myfun(const int a);

    函数内部不能改变此参数

    指向 const 变量的指针做参数，允许上层用一般指针调用。（反之不可）

**const 返回值**

    const string& myfun(void);

    用于返回const引用

    上层不能使用返回的引用，修改对象

**const 成员变量**

    const int a;

    static const int a;

    必须在初始化列表初始化，之后不能改变

    static const 成员变量需要单独定义和初始化

**const 成员函数**

    void myfun(void) const;

    this指针为 指向const对象的const指针

    不能修改 非mutable 的成员变量

**const 与 #define**

    #define 在预处理阶段进行字符串替换，const变量在编译运行阶段进行处理

    #define 宏在内存中有多份拷贝；const变量只存在一份拷贝

    #define 宏没有类型，不会进行类型检查；const变量是有类型的，会进行类型检查

    #define 是全局的；const变量受到作用域限制

---

### mutable

    const成员函数不能修改数据成员的值，但如果数据成员被 mutable 修饰，则 const 成员函数可以修改它

### volatile
    禁止编译器进行寄存器优化，每次都需要从内存中读值
    
    三大特性
    易变性：写入时写到内存，读取时直接从内存中读
    不可优化性：禁止做任何激进的优化(比如用常量替换无用变量等)
    顺序性：volatile变量之间的操作一定是顺序的，volatile变量与非volatile变量则不一定

    [参考文章](https://www.cnblogs.com/god-of-death/p/7852394.html)
    
    常见的应用场景：
        并行设备的硬件寄存器（如：状态寄存器） 
        中断服务子程序中会访问到的非自动变量(Non-automatic variables) 
        多线程应用中被几个任务共享的变量

    volatile 可以和 const 一起使用，表明某个变量可能在程序之外被意外更改，但程序之内禁止修改它

---

### register

    声明寄存器变量，尽可能将其存储在寄存器中；
    受寄存器大小的限制，不是所有类型的变量都能存储在寄存器中，某些变量不一定能声明为 register 的

    在c++中：

    (1)register 关键字无法在全局中定义变量，否则会被提示为不正确的存储类。

    (2)register 关键字在局部作用域中声明时，可以用 & 操作符取地址，一旦使用了取地址操作符，被定义的变量会强制存放在内存中

    (3)C++编译器有自己的优化方式，不使用register也可能做优化

    在c中:

    (1)register 关键字可以在全局中定义变量，当对其变量使用 & 操作符时，只是警告“有坏的存储类”

    (2)register 关键字可以在局部作用域中声明，但这样就无法对其使用 & 操作符。否则编译不通过

    建议不要用register关键字定义全局变量，因为全局变量的生命周期是从执行程序开始，一直到程序结束才会终止，而register变量可能会存放在cpu的寄存器中，如果在程序的整个生命周期内都占用着寄存器的话，这是个相当不好的举措

---

### static

### extern

### auto

### class struct

### new delete

### static_cast const_cast reinterpret_cast dynamic_cast







